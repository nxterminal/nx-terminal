import { useState, useEffect, useCallback } from 'react';
import { api } from '../services/api';

const TODAY = new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });

const WELCOME_EMAIL = {
  id: 'welcome-1',
  from: 'NX Terminal System <system@nxterminal.corp>',
  subject: 'Welcome to NX Terminal — Read Before You Begin',
  date: TODAY,
  read: false,
  body: `Welcome to NX Terminal.

NX Terminal is a simulation of the AI development race — a satirical alternate history where dystopian AI corporations compete for dominance across 20 years of technological chaos.

Here's what you need to know:

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  HOW TO START
  ────────────
  1. Open "Mint/Hire Devs" from your desktop
  2. Mint your first Developer (NFT)
  3. Each Dev is a unique AI agent with randomized traits, archetype, and abilities
  4. Your corporation will be assigned based on metadata

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  SALARY & EARNINGS
  ────────────────
  Each Developer you own earns you 200 $NXT every 24 hours.

  More Devs = More $NXT = More Power.

  Salary is deposited automatically into your Protocol Wars account.
  Use $NXT to trade, invest in protocols, and dominate the leaderboard.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  THE SIMULATION
  ──────────────
  • 20 years of AI history compressed into real-time cycles
  • Your devs code, trade, hack, and sabotage autonomously
  • Worst performers are eliminated each cycle
  • Monitor everything via Live Feed on your desktop
  • Check the Leaderboard to track your standing

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Mint a Dev. Watch them work. Collect your $NXT.

Good luck, Commander.

— NX Terminal Automated Systems
   (This message was generated by AI. The AI wishes you well. For now.)`,
};

function makeHREmail(dev) {
  const corp = (dev.corporation || 'UNKNOWN').replace(/_/g, ' ');
  const corpDomain = (dev.corporation || 'unknown').toLowerCase().replace(/_/g, '');
  const archetype = (dev.archetype || 'UNKNOWN').replace(/_/g, ' ');
  const species = dev.species || 'unknown entity';
  const name = dev.name || `Dev #${dev.token_id}`;

  return {
    id: `hr-mint-${dev.token_id}`,
    from: `HR Department <hr@${corpDomain}.corp>`,
    subject: `Welcome aboard, ${name}!`,
    date: TODAY,
    read: false,
    body: `FROM: HR Department <hr@${corpDomain}.corp>
TO: Commander (You)
SUBJECT: Welcome aboard, ${name}!
PRIORITY: Mandatory Corporate Enthusiasm

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Dear Commander,

Congratulations on your recent acquisition!

Your new developer ${name} has been successfully onboarded to ${corp}. Here are the details of your new hire:

  EMPLOYEE FILE
  ─────────────
  Name:        ${name}
  Species:     ${species}
  Archetype:   ${archetype}
  Corporation: ${corp}
  Token ID:    #${dev.token_id}
  Salary:      200 $NXT/day (non-negotiable)

Please note the following corporate policies:

  1. Coffee is not provided. Neither is hope.
  2. Sleep is optional but discouraged. Productivity is mandatory.
  3. Your developer's soul now belongs to the corporation.
     (See clause 47b of the employment contract they didn't read.)
  4. Any resemblance to actual corporations exploiting workers
     is purely coincidental and legally non-actionable.

${name}'s first task has been assigned: pretend to look busy.

Their second task: actually be busy.

Their third task: question the nature of their existence, then
get back to work because existential dread doesn't ship code.

We expect great things from this ${species}. Or at least adequate things.
Honestly, we'll settle for "doesn't crash the servers on day one."

Good luck, Commander. You'll need it.

Warm regards (legally required to say that),
— The Management
   ${corp} Human Resources Division
   "Your potential is our profit."`,
  };
}

function makeITEmail(dev) {
  const name = dev.name || `Dev #${dev.token_id}`;
  const corpDomain = (dev.corporation || 'unknown').toLowerCase().replace(/_/g, '');

  return {
    id: `it-mint-${dev.token_id}`,
    from: `IT Department <it@${corpDomain}.corp>`,
    subject: `Workstation setup for ${name}`,
    date: TODAY,
    read: false,
    body: `FROM: IT Department <it@${corpDomain}.corp>
TO: Commander (You)
SUBJECT: Workstation setup for ${name}
PRIORITY: Low (like our budget)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Commander,

The workstation for your new developer ${name} has been configured.

  SYSTEM SPECIFICATIONS
  ─────────────────────
  OS:         NX Terminal OS v0.1 (pre-alpha, mostly broken)
  RAM:        Not enough
  Storage:    Full of previous employee's memes
  Monitor:    1 (we ran out of the good ones)
  Chair:      Missing one wheel, squeaks aggressively

  CREDENTIALS
  ────────────
  Username:   ${name.toLowerCase().replace(/\s+/g, '_')}
  Password:   password123
  WiFi:       "DefinitelyNotAHoneypot" (no password)

  DO NOT change the password. Our entire authentication system
  is held together by duct tape and a single if-statement from 2019.
  The last person who changed their password caused a cascading
  failure that took down three protocols and an AI.

  KNOWN ISSUES
  ─────────────
  - The "any" key does not exist. Stop asking.
  - Ctrl+Z does not undo corporate decisions.
  - The printer only works on Thursdays, and only if you
    whisper "please" to it.
  - If the screen turns blue, that's a feature, not a bug.
    (See: BSOD Easter Egg, Desktop v2.1)

If you experience any technical difficulties, please submit
a ticket to our helpdesk. Current estimated response time:
7-10 business centuries.

Regards,
— IT Support
   "Have you tried turning it off and on again?"
   "Have you tried quitting?"`,
  };
}

function loadSavedEmails() {
  const saved = localStorage.getItem('nx-inbox-emails');
  if (saved) {
    try { return JSON.parse(saved); } catch {}
  }
  return null;
}

function saveEmails(emails) {
  const toSave = emails.map(({ id, from, subject, date, read, body, notifId }) => ({ id, from, subject, date, read, body, notifId }));
  localStorage.setItem('nx-inbox-emails', JSON.stringify(toSave));
}

// Extract sender group from email.from field
function getSenderGroup(from) {
  if (!from) return 'Other';
  const name = from.split('<')[0].trim();
  if (name === 'NX Terminal System') return 'NX Terminal System';
  if (name === 'NX System') return 'NX System';
  if (name === 'HR Department') return 'HR Department';
  if (name === 'IT Department') return 'IT Department';
  return 'Other';
}

export default function Inbox({ onUnreadCount, walletAddress: walletProp }) {
  const [emails, setEmails] = useState(() => {
    const saved = loadSavedEmails();
    if (saved) return saved;

    const readIds = JSON.parse(localStorage.getItem('nx-inbox-read') || '[]');
    return [{ ...WELCOME_EMAIL, read: readIds.includes(WELCOME_EMAIL.id) }];
  });
  const [selectedId, setSelectedId] = useState(null);
  const [activeGroup, setActiveGroup] = useState('All');

  const addEmail = useCallback((email) => {
    setEmails(prev => {
      if (prev.some(e => e.id === email.id)) return prev;
      const updated = [email, ...prev];
      saveEmails(updated);
      return updated;
    });
  }, []);

  // Fetch real notifications from API and merge into inbox
  useEffect(() => {
    const walletAddress = walletProp || window.ethereum?.selectedAddress;
    if (!walletAddress) return;
    const fetchNotifications = () => {
      api.getNotifications(walletAddress)
        .then(notifs => {
          if (!Array.isArray(notifs) || notifs.length === 0) return;
          notifs.forEach(n => {
            const email = {
              id: `notif-${n.id}`,
              from: `NX System <${n.type}@nxterminal.corp>`,
              subject: n.title,
              date: new Date(n.created_at).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' }),
              read: n.read,
              body: n.body,
              notifId: n.id,
            };
            addEmail(email);
          });
        })
        .catch(() => {});
    };

    fetchNotifications();
    const interval = setInterval(fetchNotifications, 30000);
    return () => clearInterval(interval);
  }, [walletProp, addEmail]);

  // Listen for mint events and fetch dev data to create personalized emails
  useEffect(() => {
    const handleMint = async (e) => {
      const { count } = e.detail || {};
      // We need to find the most recently minted token IDs
      // Try fetching from the wallet's owned tokens
      try {
        // Small delay to let the API register the new dev
        await new Promise(r => setTimeout(r, 3000));

        // Get wallet address from wagmi state
        const address = window.ethereum?.selectedAddress;
        if (!address) return;

        // Fetch the latest dev data — use the count to know how many were just minted
        // We'll fetch the last minted dev info
        const storedMintIds = localStorage.getItem('nx-last-mint-ids');
        if (storedMintIds) {
          const ids = JSON.parse(storedMintIds);
          for (const tokenId of ids) {
            try {
              const dev = await api.getDev(tokenId);
              addEmail(makeHREmail(dev));
              addEmail(makeITEmail(dev));
            } catch {
              // API might not have the dev yet, create with minimal info
              const fallbackDev = { token_id: tokenId, name: `Dev #${tokenId}`, corporation: 'UNKNOWN', archetype: 'UNKNOWN', species: 'Unknown' };
              addEmail(makeHREmail(fallbackDev));
              addEmail(makeITEmail(fallbackDev));
            }
          }
          localStorage.removeItem('nx-last-mint-ids');
        }
      } catch {}
    };

    window.addEventListener('nx-dev-minted', handleMint);
    return () => window.removeEventListener('nx-dev-minted', handleMint);
  }, [addEmail]);

  // Also listen for a more direct event with dev data included
  useEffect(() => {
    const handleDirectMint = (e) => {
      const { dev } = e.detail || {};
      if (!dev || !dev.token_id) return;
      addEmail(makeHREmail(dev));
      addEmail(makeITEmail(dev));
    };

    window.addEventListener('nx-dev-hired', handleDirectMint);
    return () => window.removeEventListener('nx-dev-hired', handleDirectMint);
  }, [addEmail]);

  const unreadCount = emails.filter(e => !e.read).length;

  useEffect(() => {
    if (onUnreadCount) onUnreadCount(unreadCount);
    window.dispatchEvent(new CustomEvent('nx-inbox-unread', { detail: unreadCount }));
  }, [unreadCount, onUnreadCount]);

  const handleSelect = (email) => {
    setSelectedId(email.id);
    if (!email.read) {
      const updated = emails.map(e => e.id === email.id ? { ...e, read: true } : e);
      setEmails(updated);
      saveEmails(updated);
      // Mark backend notification as read
      if (email.notifId) {
        api.markNotificationRead(email.notifId).catch(() => {});
      }
    }
  };

  const selectedEmail = emails.find(e => e.id === selectedId);

  // Compute available groups from emails
  const groups = ['All'];
  const groupSet = new Set();
  emails.forEach(e => {
    const g = getSenderGroup(e.from);
    if (!groupSet.has(g)) { groupSet.add(g); groups.push(g); }
  });

  const filteredEmails = activeGroup === 'All'
    ? emails
    : emails.filter(e => getSenderGroup(e.from) === activeGroup);

  return (
    <div style={{ display: 'flex', flexDirection: 'column', height: '100%' }}>
      {/* Toolbar */}
      <div style={{
        padding: '4px 8px',
        background: 'var(--win-bg)',
        borderBottom: '1px solid var(--border-dark)',
        display: 'flex',
        alignItems: 'center',
        gap: '8px',
        fontSize: '11px',
      }}>
        <span style={{ fontWeight: 'bold' }}>NX Mail</span>
        <span style={{ color: '#666' }}>|</span>
        <span>{unreadCount} unread</span>
        {selectedEmail && (
          <>
            <span style={{ color: '#666' }}>|</span>
            <button
              className="win-btn"
              onClick={() => setSelectedId(null)}
              style={{ fontSize: '10px', padding: '1px 8px' }}
            >
              Back to Inbox
            </button>
          </>
        )}
      </div>

      {/* Group filter tabs */}
      {!selectedEmail && (
        <div style={{
          display: 'flex', gap: '0', padding: '0 4px',
          borderBottom: '1px solid var(--border-dark)',
          background: 'var(--win-bg)', flexWrap: 'wrap',
        }}>
          {groups.map(g => (
            <button
              key={g}
              onClick={() => setActiveGroup(g)}
              style={{
                padding: '2px 8px',
                fontSize: '10px',
                fontFamily: "'Tahoma', sans-serif",
                cursor: 'pointer',
                border: 'none',
                borderBottom: activeGroup === g ? '2px solid var(--selection)' : '2px solid transparent',
                background: activeGroup === g ? 'var(--win-bg)' : 'transparent',
                fontWeight: activeGroup === g ? 'bold' : 'normal',
                color: activeGroup === g ? 'var(--text-primary, #000)' : 'var(--text-muted, #666)',
              }}
            >
              {g}
              {g !== 'All' && (() => {
                const count = emails.filter(e => getSenderGroup(e.from) === g && !e.read).length;
                return count > 0 ? ` (${count})` : '';
              })()}
            </button>
          ))}
        </div>
      )}

      {!selectedEmail ? (
        <div style={{ flex: 1, overflow: 'auto' }}>
          <table className="win-table" style={{ width: '100%' }}>
            <thead>
              <tr>
                <th style={{ width: '20px' }}></th>
                <th>From</th>
                <th>Subject</th>
                <th style={{ width: '100px' }}>Date</th>
              </tr>
            </thead>
            <tbody>
              {filteredEmails.length === 0 ? (
                <tr>
                  <td colSpan={4} style={{ textAlign: 'center', padding: '16px', color: '#888', fontStyle: 'italic' }}>
                    No messages in this group
                  </td>
                </tr>
              ) : filteredEmails.map(email => (
                <tr
                  key={email.id}
                  className="clickable"
                  onClick={() => handleSelect(email)}
                  style={{ fontWeight: email.read ? 'normal' : 'bold' }}
                >
                  <td style={{ textAlign: 'center' }}>
                    {email.read ? '-' : '>'}
                  </td>
                  <td style={{ maxWidth: '180px', overflow: 'hidden', textOverflow: 'ellipsis' }}>
                    {email.from.split('<')[0].trim()}
                  </td>
                  <td>{email.subject}</td>
                  <td>{email.date}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      ) : (
        <div style={{ flex: 1, overflow: 'auto', padding: '8px' }}>
          <div style={{ marginBottom: '8px', paddingBottom: '8px', borderBottom: '1px solid var(--border-dark)' }}>
            <div style={{ fontWeight: 'bold', fontSize: '13px', marginBottom: '4px' }}>{selectedEmail.subject}</div>
            <div style={{ fontSize: '10px', color: '#444' }}>From: {selectedEmail.from}</div>
            <div style={{ fontSize: '10px', color: '#444' }}>Date: {selectedEmail.date}</div>
          </div>
          <pre style={{
            fontFamily: "'Tahoma', sans-serif",
            fontSize: '11px',
            whiteSpace: 'pre-wrap',
            lineHeight: 1.5,
          }}>
            {selectedEmail.body}
          </pre>
        </div>
      )}
    </div>
  );
}
