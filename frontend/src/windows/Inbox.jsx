import { useState, useEffect } from 'react';
import { api } from '../services/api';

const TODAY = new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });

const WELCOME_EMAIL = {
  id: 'welcome-1',
  from: 'NX Terminal System <system@nxterminal.corp>',
  subject: 'Welcome to NX Terminal — Read Before You Begin',
  date: TODAY,
  read: false,
  body: `Welcome to NX Terminal.

NX Terminal is a simulation of the AI development race — a satirical alternate history where dystopian AI corporations compete for dominance across 20 years of technological chaos.

Here's what you need to know:

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  HOW TO START
  ────────────
  1. Open "Mint/Hire Devs" from your desktop
  2. Mint your first Developer (NFT)
  3. Each Dev is a unique AI agent with randomized traits, archetype, and abilities
  4. Your corporation will be assigned based on metadata

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  SALARY & EARNINGS
  ────────────────
  Each Developer you own earns you 200 $NXT every 24 hours.

  More Devs = More $NXT = More Power.

  Salary is deposited automatically into your Protocol Wars account.
  Use $NXT to trade, invest in protocols, and dominate the leaderboard.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  THE SIMULATION
  ──────────────
  • 20 years of AI history compressed into real-time cycles
  • Your devs code, trade, hack, and sabotage autonomously
  • Worst performers are eliminated each cycle
  • Monitor everything via Live Feed on your desktop
  • Check the Leaderboard to track your standing

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Mint a Dev. Watch them work. Collect your $NXT.

Good luck, Commander.

— NX Terminal Automated Systems
   (This message was generated by AI. The AI wishes you well. For now.)`,
};

function loadSavedEmails() {
  const saved = localStorage.getItem('nx-inbox-emails');
  if (saved) {
    try {
      const parsed = JSON.parse(saved);
      // Filter out old notification emails (notifId means it came from backend).
      // Only keep the static welcome email.
      const filtered = parsed.filter(e => e.id === WELCOME_EMAIL.id || !e.notifId);
      if (filtered.length !== parsed.length) {
        localStorage.setItem('nx-inbox-emails', JSON.stringify(filtered));
      }
      return filtered;
    } catch {}
  }
  return null;
}

function saveEmails(emails) {
  const toSave = emails.map(({ id, from, subject, date, read, body, notifId }) => ({ id, from, subject, date, read, body, notifId }));
  localStorage.setItem('nx-inbox-emails', JSON.stringify(toSave));
}

// Extract sender group from email.from field
function getSenderGroup(from) {
  if (!from) return 'Other';
  const name = from.split('<')[0].trim();
  if (name === 'NX Terminal System') return 'NX Terminal System';
  return 'Other';
}

export default function Inbox({ onUnreadCount, walletAddress: walletProp }) {
  const [emails, setEmails] = useState(() => {
    const saved = loadSavedEmails();
    if (saved) return saved;

    const readIds = JSON.parse(localStorage.getItem('nx-inbox-read') || '[]');
    return [{ ...WELCOME_EMAIL, read: readIds.includes(WELCOME_EMAIL.id) }];
  });
  const [selectedId, setSelectedId] = useState(null);
  const [activeGroup, setActiveGroup] = useState('All');
  const [selectedIds, setSelectedIds] = useState(new Set());

  const unreadCount = emails.filter(e => !e.read).length;

  useEffect(() => {
    if (onUnreadCount) onUnreadCount(unreadCount);
    window.dispatchEvent(new CustomEvent('nx-inbox-unread', { detail: unreadCount }));
  }, [unreadCount, onUnreadCount]);

  const handleSelect = (email) => {
    setSelectedId(email.id);
    if (!email.read) {
      const updated = emails.map(e => e.id === email.id ? { ...e, read: true } : e);
      setEmails(updated);
      saveEmails(updated);
      // Mark backend notification as read
      if (email.notifId) {
        api.markNotificationRead(email.notifId).catch(() => {});
      }
    }
  };

  const selectedEmail = emails.find(e => e.id === selectedId);

  // Compute available groups from emails
  const groups = ['All'];
  const groupSet = new Set();
  emails.forEach(e => {
    const g = getSenderGroup(e.from);
    if (!groupSet.has(g)) { groupSet.add(g); groups.push(g); }
  });

  const filteredEmails = activeGroup === 'All'
    ? emails
    : emails.filter(e => getSenderGroup(e.from) === activeGroup);

  const toggleSelect = (emailId, e) => {
    e.stopPropagation();
    setSelectedIds(prev => {
      const next = new Set(prev);
      if (next.has(emailId)) next.delete(emailId);
      else next.add(emailId);
      return next;
    });
  };

  const handleSelectAll = () => {
    const allSelected = filteredEmails.every(e => selectedIds.has(e.id));
    if (allSelected) {
      setSelectedIds(new Set());
    } else {
      setSelectedIds(new Set(filteredEmails.map(e => e.id)));
    }
  };

  const handleMarkSelectedRead = () => {
    if (selectedIds.size === 0) return;
    const updated = emails.map(e =>
      selectedIds.has(e.id) ? { ...e, read: true } : e
    );
    setEmails(updated);
    saveEmails(updated);
    // Mark backend notifications as read
    emails.forEach(e => {
      if (selectedIds.has(e.id) && !e.read && e.notifId) {
        api.markNotificationRead(e.notifId).catch(() => {});
      }
    });
    setSelectedIds(new Set());
  };

  const handleDeleteSelected = () => {
    if (selectedIds.size === 0) return;
    const updated = emails.filter(e => !selectedIds.has(e.id));
    setEmails(updated);
    saveEmails(updated);
    setSelectedIds(new Set());
    if (selectedId && selectedIds.has(selectedId)) setSelectedId(null);
  };

  const selectedUnreadCount = [...selectedIds].filter(id => {
    const e = emails.find(em => em.id === id);
    return e && !e.read;
  }).length;

  return (
    <div style={{ display: 'flex', flexDirection: 'column', height: '100%' }}>
      {/* Toolbar */}
      <div style={{
        padding: '4px 8px',
        background: 'var(--win-bg)',
        borderBottom: '1px solid var(--border-dark)',
        display: 'flex',
        alignItems: 'center',
        gap: '8px',
        fontSize: '11px',
      }}>
        <span style={{ fontWeight: 'bold' }}>NX Mail</span>
        <span style={{ color: '#666' }}>|</span>
        <span>{unreadCount} unread</span>
        {selectedEmail ? (
          <>
            <span style={{ color: '#666' }}>|</span>
            <button
              className="win-btn"
              onClick={() => setSelectedId(null)}
              style={{ fontSize: '10px', padding: '1px 8px' }}
            >
              Back to Inbox
            </button>
          </>
        ) : (
          <>
            {selectedIds.size > 0 && (
              <>
                <span style={{ color: '#666' }}>|</span>
                <span style={{ fontWeight: 'bold' }}>{selectedIds.size} selected</span>
                <button
                  className="win-btn"
                  onClick={handleMarkSelectedRead}
                  disabled={selectedUnreadCount === 0}
                  style={{ fontSize: '10px', padding: '1px 8px' }}
                >
                  Mark as Read ({selectedUnreadCount})
                </button>
                <button
                  className="win-btn"
                  onClick={handleDeleteSelected}
                  style={{ fontSize: '10px', padding: '1px 8px' }}
                >
                  Delete ({selectedIds.size})
                </button>
                <button
                  className="win-btn"
                  onClick={() => setSelectedIds(new Set())}
                  style={{ fontSize: '10px', padding: '1px 8px' }}
                >
                  Clear
                </button>
              </>
            )}
          </>
        )}
      </div>

      {/* Group filter tabs */}
      {!selectedEmail && (
        <div style={{
          display: 'flex', gap: '0', padding: '0 4px',
          borderBottom: '1px solid var(--border-dark)',
          background: 'var(--win-bg)', flexWrap: 'wrap',
        }}>
          {groups.map(g => (
            <button
              key={g}
              onClick={() => setActiveGroup(g)}
              style={{
                padding: '2px 8px',
                fontSize: '10px',
                fontFamily: "'Tahoma', sans-serif",
                cursor: 'pointer',
                border: 'none',
                borderBottom: activeGroup === g ? '2px solid var(--selection)' : '2px solid transparent',
                background: activeGroup === g ? 'var(--win-bg)' : 'transparent',
                fontWeight: activeGroup === g ? 'bold' : 'normal',
                color: activeGroup === g ? 'var(--text-primary, #000)' : 'var(--text-muted, #666)',
              }}
            >
              {g}
              {g !== 'All' && (() => {
                const count = emails.filter(e => getSenderGroup(e.from) === g && !e.read).length;
                return count > 0 ? ` (${count})` : '';
              })()}
            </button>
          ))}
        </div>
      )}

      {!selectedEmail ? (
        <div style={{ flex: 1, overflow: 'auto' }}>
          <table className="win-table" style={{ width: '100%' }}>
            <thead>
              <tr>
                <th style={{ width: '24px', textAlign: 'center' }}>
                  <input
                    type="checkbox"
                    checked={filteredEmails.length > 0 && filteredEmails.every(e => selectedIds.has(e.id))}
                    onChange={handleSelectAll}
                    style={{ cursor: 'pointer' }}
                  />
                </th>
                <th style={{ width: '20px' }}></th>
                <th>From</th>
                <th>Subject</th>
                <th style={{ width: '100px' }}>Date</th>
              </tr>
            </thead>
            <tbody>
              {filteredEmails.length === 0 ? (
                <tr>
                  <td colSpan={5} style={{ textAlign: 'center', padding: '16px', color: '#888', fontStyle: 'italic' }}>
                    No messages in this group
                  </td>
                </tr>
              ) : filteredEmails.map(email => (
                <tr
                  key={email.id}
                  className="clickable"
                  onClick={() => handleSelect(email)}
                  style={{
                    fontWeight: email.read ? 'normal' : 'bold',
                    background: selectedIds.has(email.id) ? 'var(--selection)' : undefined,
                    color: selectedIds.has(email.id) ? 'var(--selection-text)' : undefined,
                  }}
                >
                  <td style={{ textAlign: 'center' }}>
                    <input
                      type="checkbox"
                      checked={selectedIds.has(email.id)}
                      onChange={(e) => toggleSelect(email.id, e)}
                      onClick={(e) => e.stopPropagation()}
                      style={{ cursor: 'pointer' }}
                    />
                  </td>
                  <td style={{ textAlign: 'center' }}>
                    {email.read ? '-' : '>'}
                  </td>
                  <td style={{ maxWidth: '180px', overflow: 'hidden', textOverflow: 'ellipsis' }}>
                    {email.from.split('<')[0].trim()}
                  </td>
                  <td>{email.subject}</td>
                  <td>{email.date}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      ) : (
        <div style={{ flex: 1, overflow: 'auto', padding: '8px' }}>
          <div style={{ marginBottom: '8px', paddingBottom: '8px', borderBottom: '1px solid var(--border-dark)' }}>
            <div style={{ fontWeight: 'bold', fontSize: '13px', marginBottom: '4px' }}>{selectedEmail.subject}</div>
            <div style={{ fontSize: '10px', color: '#444' }}>From: {selectedEmail.from}</div>
            <div style={{ fontSize: '10px', color: '#444' }}>Date: {selectedEmail.date}</div>
          </div>
          <pre style={{
            fontFamily: "'Tahoma', sans-serif",
            fontSize: '11px',
            whiteSpace: 'pre-wrap',
            lineHeight: 1.5,
          }}>
            {selectedEmail.body}
          </pre>
        </div>
      )}
    </div>
  );
}
